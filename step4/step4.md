## 施工前瞻

现在应该把整个调用过程纳入考量了：

1. 如何通过简单的方式调用校验模块？

2. 具体操作 dom 元素的工作应该交给调用者还是校验模块？

3. 如何有效地给校验模块传递规则？

4. 校验规则的优先级怎么定义？如何优雅地做到优先级调用？


## 施工结果：

1. 简单用法：

简单字符串验证，需要自己取得需要验证的字符串传入。

let v = new validator();
v.isEmail('940095072@');
v.isPassword('94009');

2. 表单验证：

复杂的表单验证，触发时机可以时input元素失去焦点的时候，也可以时点击提交按钮的时候
默认会在点击提交按钮的时候调用表单验证。

当然也可以选择不动态验证，默认会给所有规定了规则的元素绑上 onblur 事件的监听器，可以显示地指定onblur: 'false' 来阻止这个默认规则生效。

var a = new validator('example_form',[
    {
        // 表单中input元素的 id 字段 ( id/name 应当至少有一个，两者都有也可, 为了避免歧义和不必要的误解，最好只指定一个)
        // 注意！使用name的时候应该时希望能够批量操作一批dom元素，这个时候避免使用id，以免验证功能失效
        id: 'email-1',
        (// 表单中input元素的 name 字段
        name: 'hello-email',)
        // 类别，指定希望绑定的默认规则，可以没有
        category: 'email',
        // 希望输出的，除了“不能为空”的提示信息。
        msg:"请输入合法的密码!长度应在6-30位包含数字和字母。"
        // 验证条件 (简化用法，一般为两种或两种以下)
        rules: 'is_email|max_length(12)',
        onblur: 'true'
    },{
        name: 'sex',
        category: 'sex',
        msg:"请你选择性别{{sex}}|请输入数字",
        rules: 'required',
        onblur: 'false'
    }
]， )

3. 分离规则绑定函数

4. 代码模块化管理

5. bug 处理

6. 调试模块优化

7. 调用接口时传参处理